# Graphite: Stream Management

The Graphite chain carries the information necessary to compute the current state of the Filecoin network. This guide explains how to manage several aspects of the chain, including how to decrease your node's sync time by loading the chain from a snapshot.

## Data persistence

To run a Ceramic node in production, it is critical to persist the multiaddress, IPFS repo and the Ceramic state store. The form of storage you choose should also be configured for disaster recovery with data redundancy, some form of snapshotting and/or backups.

> Loss of this data can result in permanent loss of Ceramic streams and will cause your node to be in a corrupt state.

The IPFS repo and the Ceramic state store are stored on your machine's filesystem by default. The IPFS repo defaults to a directory called `ipfs` located wherever you run the `ceramic daemon` command (or the `ipfs-daemon` process when running IPFS out-of-process). The Ceramic state store defaults to `~/.ceramic/statestore`.

The fastest way to ensure data persistence is by mounting a persistent volume to your instances and configuring the Ceramic and IPFS nodes to write to the mount location. The mounted volume should be configured such that the data persists if the instance shuts down.

You can also use AWS S3 for data storage which is supported for both Ceramic and IPFS. Below are examples of the configuration for both storage options.

### IPFS Repo

The IPFS repo holds configuration settings and all the raw IPFS data for the Ceramic streams used by your node. It is essential to keep the file names `config` generated by IPFS so that your node can stay connected to the Ceramic network. This file is located at the root of the IPFS repo directory.

!!! info ""
The IPFS config file holds your node's private key which is used to generate your node's peerId and multiaddress. If this file is deleted it will be re-created on start with a different key, peerId and multiaddress. This will result in your node and the rest of the network not being able to connect to each other.

!!! warning ""
Environment variables should be written to your profile file, or otherwise injected into your environment on start so that they persist between reboots.

#### **Option A. Volume Storage**

```bash
# Environment variable to use a mounted volume for IPFS persistence
export IPFS_PATH="/mnt_volume_path_for_ipfs"
```

#### **Option B. AWS S3**

```bash
# Environment variables to use S3 for IPFS persistence
export IPFS_S3_REPO_ENABLED="true"
export IPFS_PATH="directory_for_the_bucket"
export AWS_BUCKET_NAME="bucket_name"
export AWS_ACCESS_KEY_ID="aws_access_key_id"
export AWS_SECRET_ACCESS_KEY="aws_secret_access_key"
export IPFS_BACKEND_ROOT="s3"
export IPFS_BACKEND_BLOCKS="s3"
export IPFS_BACKEND_KEYS="s3"
export IPFS_BACKEND_PINS="s3"
export IPFS_BACKEND_DATASTORE="s3"
```

```json
// IPFS AWS S3 policy for the access key
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": [
        "s3:GetObject",
        "s3:ListBucket",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Effect": "Allow",
      "Resource": ["ipfs_bucket_arn", "ipfs_bucket_arn/*"]
    }
  ]
}
```

### Ceramic State Store

The Ceramic state store holds commits for pinned streams and the acts as a cache for the Ceramic streams that your node creates or loads. To ensure that the data you create with your Ceramic node does not get lost you must pin streams you care about and you must ensure that the state store does not get deleted.

#### **Option A. Volume Storage**

Using `daemon.config.json`
```json
    "state-store": {
        "mode": "fs",
        "local-directory": "/mnt_volume_path_for_statestore",
    },
```

Using CLI flags
```bash
# CLI flag to use a mounted volume for Ceramic state store persistence
ceramic daemon --state-store-directory /mnt_volume_path_for_statestore
```

#### **Option B. AWS S3**

Using `daemon.config.json`
```json
    "state-store": {
        "mode": "s3",
        "s3-bucket": "bucket_name"
    },
```

Using CLI flags
```bash
# CLI flag to use S3 for Ceramic state store persistence
ceramic daemon --state-store-s3-bucket bucket_name
```

Ceramic state store AWS S3 policy for the access key
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": [
        "s3:ListBucket",
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Effect": "Allow",
      "Resource": ["state_store_bucket_arn", "state_store_bucket_arn/*"]
    }
  ]
}
```

## Syncing streams

---

Graphite will automatically sync to the latest *stream tip* for each stream itsby fetching the block headers from the current head down to the last synced epoch. The node then retrieves and verifies all the blocks from the last synced epoch to the current head. Once Lotus is synced, it will learn about new blocks as they are mined for every epoch and verify them accordingly. Every epoch might see a variable number of mined blocks.